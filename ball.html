<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#10B981">
    <meta name="apple-mobile-web-app-title" content="Magic Ball">
    <title>Magic Ball - PWA</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #10B981 0%, #059669 100%);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        #ball {
            position: absolute;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #ffffff, #f0f0f0);
            box-shadow: 
                inset -8px -8px 16px rgba(0,0,0,0.2),
                inset 8px 8px 16px rgba(255,255,255,0.6),
                0 15px 30px rgba(0,0,0,0.3);
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
            transition: transform 0.1s linear;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }

        .ball-inner {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            bottom: 10px;
            border-radius: 50%;
            background: radial-gradient(circle at 40% 40%, #ffffff, #e8e8e8);
            box-shadow: 
                inset 4px 4px 8px rgba(255,255,255,0.8),
                inset -4px -4px 8px rgba(0,0,0,0.1);
        }

        .ball-reflection {
            position: absolute;
            top: 15px;
            left: 15px;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.8), transparent 70%);
            z-index: 3;
        }

        .ball-shadow {
            position: absolute;
            width: 80px;
            height: 20px;
            background: radial-gradient(ellipse at center, 
                rgba(0,0,0,0.2) 0%,
                rgba(0,0,0,0) 70%);
            border-radius: 50%;
            z-index: 1;
            transition: all 0.1s ease;
        }

        /* Boundary indicator - bisa dihapus jika tidak perlu */
        .boundary-indicator {
            position: fixed;
            border: 2px solid rgba(255,255,255,0.2);
            pointer-events: none;
            z-index: 1;
        }
        
        .boundary-top {
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            border-bottom: 2px solid rgba(255,255,255,0.3);
        }
        
        .boundary-bottom {
            bottom: 0;
            left: 0;
            right: 0;
            height: 2px;
            border-top: 2px solid rgba(255,255,255,0.3);
        }
        
        .boundary-left {
            top: 0;
            left: 0;
            bottom: 0;
            width: 2px;
            border-right: 2px solid rgba(255,255,255,0.3);
        }
        
        .boundary-right {
            top: 0;
            right: 0;
            bottom: 0;
            width: 2px;
            border-left: 2px solid rgba(255,255,255,0.3);
        }

        .instructions {
            position: fixed;
            top: 30px;
            left: 0;
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.9);
            font-size: 16px;
            padding: 0 20px;
            z-index: 3;
            pointer-events: none;
            animation: fadeOut 4s forwards;
        }

        @keyframes fadeOut {
            0% { opacity: 1; }
            70% { opacity: 1; }
            100% { opacity: 0; }
        }

        .permission-prompt {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            padding: 20px;
            text-align: center;
            color: white;
        }

        .permission-prompt.hidden {
            display: none;
        }

        .permission-prompt h2 {
            margin-bottom: 20px;
            color: #10B981;
        }

        .permission-prompt p {
            margin-bottom: 30px;
            color: rgba(255,255,255,0.8);
            max-width: 300px;
            line-height: 1.5;
        }

        .permission-prompt button {
            background: linear-gradient(135deg, #10B981 0%, #059669 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 18px;
            cursor: pointer;
            margin: 10px;
        }

        .permission-prompt button:active {
            transform: scale(0.98);
        }
    </style>
</head>
<body>
    <!-- Boundary indicators (optional visual aid) -->
    <div class="boundary-indicator boundary-top"></div>
    <div class="boundary-indicator boundary-bottom"></div>
    <div class="boundary-indicator boundary-left"></div>
    <div class="boundary-indicator boundary-right"></div>

    <!-- Permission Prompt -->
    <div id="permissionPrompt" class="permission-prompt">
        <h2>ðŸŽ® Magic Ball Physics</h2>
        <p>Bola akan bergerak sesuai kemiringan HP Anda. Izinkan akses ke sensor gerak untuk pengalaman terbaik.</p>
        <button id="grantPermissionBtn">Izinkan Sensor Gerak</button>
        <p style="font-size: 12px; margin-top: 20px; color: rgba(255,255,255,0.6);">
            Tekan tombol di atas, lalu izinkan ketika browser meminta izin
        </p>
    </div>

    <!-- Instructions -->
    <div class="instructions">
        Miringkan HP untuk menggerakkan bola<br>
        Sentuh bola untuk mendorong
    </div>

    <!-- Ball and Shadow -->
    <div id="ball">
        <div class="ball-inner"></div>
        <div class="ball-reflection"></div>
    </div>
    <div class="ball-shadow"></div>

    <script>
        // ============================
        // FIXED BALL PHYSICS - STAYS WITHIN BOUNDARIES
        // ============================
        class FixedBallPhysics {
            constructor() {
                // Ball properties - posisi dihitung dari center
                this.radius = 50; // Radius 50px untuk bola diameter 100px
                this.x = window.innerWidth / 2; // Center X
                this.y = window.innerHeight / 2; // Center Y
                this.vx = 0;
                this.vy = 0;
                
                // Physics properties
                this.gravity = 0.5;
                this.friction = 0.98;
                this.bounce = 0.8;
                this.tiltStrength = 0.12;
                
                // Gyro data
                this.beta = 0;    // Front-back tilt
                this.gamma = 0;   // Left-right tilt
                this.gyroAvailable = false;
                
                // Touch state
                this.isDragging = false;
                
                // Initialize boundaries dengan benar
                this.updateBoundaries();
                
                console.log("Ball boundaries:", {
                    minX: this.minX,
                    maxX: this.maxX,
                    minY: this.minY,
                    maxY: this.maxY,
                    radius: this.radius,
                    screenWidth: window.innerWidth,
                    screenHeight: window.innerHeight
                });
            }
            
            updateBoundaries() {
                // Hitung batasan dengan benar: bola tidak boleh keluar layar
                // Center position harus berada dalam batas radius dari tepi
                this.minX = this.radius; // Minimal jarak dari kiri = radius
                this.minY = this.radius; // Minimal jarak dari atas = radius
                this.maxX = window.innerWidth - this.radius; // Maksimal jarak dari kiri = lebar layar - radius
                this.maxY = window.innerHeight - this.radius; // Maksimal jarak dari atas = tinggi layar - radius
            }
            
            initGyro() {
                if (window.DeviceOrientationEvent) {
                    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                        // iOS 13+ - akan minta permission via button
                        console.log("iOS 13+ terdeteksi");
                    } else {
                        // Android dan iOS lama
                        this.startGyroListening();
                    }
                }
            }
            
            async requestPermission() {
                try {
                    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                        const permission = await DeviceOrientationEvent.requestPermission();
                        if (permission === 'granted') {
                            this.startGyroListening();
                            return true;
                        }
                    }
                } catch (e) {
                    console.log("Permission error:", e);
                }
                return false;
            }
            
            startGyroListening() {
                this.gyroAvailable = true;
                window.addEventListener('deviceorientation', (e) => {
                    this.beta = e.beta || 0;   // Front-back tilt (-180 to 180)
                    this.gamma = e.gamma || 0; // Left-right tilt (-90 to 90)
                    
                    // Normalize values
                    const normalizedBeta = Math.max(-60, Math.min(60, this.beta)) / 60;
                    const normalizedGamma = Math.max(-45, Math.min(45, this.gamma)) / 45;
                    
                    // Update velocities based on tilt
                    this.vx += normalizedGamma * this.tiltStrength;
                    this.vy += normalizedBeta * this.tiltStrength * 0.7;
                });
            }
            
            update() {
                // Apply gravity (always pulls down)
                this.vy += this.gravity * 0.05;
                
                // Apply friction
                this.vx *= this.friction;
                this.vy *= this.friction;
                
                // Update position
                this.x += this.vx;
                this.y += this.vy;
                
                // Handle collisions with proper boundary checking
                this.handleBoundaryCollisions();
                
                // Double-check boundaries (safety)
                this.clampToBoundaries();
                
                return {
                    x: this.x - this.radius, // Convert center to top-left for CSS
                    y: this.y - this.radius, // Convert center to top-left for CSS
                    vx: this.vx,
                    vy: this.vy
                };
            }
            
            handleBoundaryCollisions() {
                let collided = false;
                
                // Check left boundary (using center position)
                if (this.x < this.minX) {
                    collided = true;
                    this.x = this.minX;
                    this.vx = Math.abs(this.vx) * this.bounce;
                }
                
                // Check right boundary
                if (this.x > this.maxX) {
                    collided = true;
                    this.x = this.maxX;
                    this.vx = -Math.abs(this.vx) * this.bounce;
                }
                
                // Check top boundary
                if (this.y < this.minY) {
                    collided = true;
                    this.y = this.minY;
                    this.vy = Math.abs(this.vy) * this.bounce;
                }
                
                // Check bottom boundary
                if (this.y > this.maxY) {
                    collided = true;
                    this.y = this.maxY;
                    this.vy = -Math.abs(this.vy) * this.bounce;
                    
                    // Extra friction on bottom
                    this.vx *= 0.9;
                }
                
                // Damping for collisions
                if (collided) {
                    this.vx *= 0.95;
                    this.vy *= 0.95;
                }
                
                // Stop very slow movement
                if (Math.abs(this.vx) < 0.05) this.vx = 0;
                if (Math.abs(this.vy) < 0.05) this.vy = 0;
            }
            
            clampToBoundaries() {
                // Safety clamp - ensure ball stays within bounds
                this.x = Math.max(this.minX, Math.min(this.maxX, this.x));
                this.y = Math.max(this.minY, Math.min(this.maxY, this.y));
            }
            
            startDrag(x, y) {
                this.isDragging = true;
                this.dragOffsetX = x - this.x;
                this.dragOffsetY = y - this.y;
                this.vx = 0;
                this.vy = 0;
            }
            
            updateDrag(x, y) {
                if (!this.isDragging) return;
                
                // Calculate new center position
                let newX = x - this.dragOffsetX;
                let newY = y - this.dragOffsetY;
                
                // Constrain to boundaries while dragging
                newX = Math.max(this.minX, Math.min(this.maxX, newX));
                newY = Math.max(this.minY, Math.min(this.maxY, newY));
                
                this.vx = (newX - this.x) * 0.7;
                this.vy = (newY - this.y) * 0.7;
                
                this.x = newX;
                this.y = newY;
            }
            
            endDrag() {
                if (!this.isDragging) return;
                this.isDragging = false;
                
                // Give momentum when released
                this.vx *= 1.5;
                this.vy *= 1.5;
            }
            
            addImpulse(impulseX, impulseY) {
                this.vx += impulseX;
                this.vy += impulseY;
            }
            
            reset() {
                this.x = window.innerWidth / 2;
                this.y = window.innerHeight / 2;
                this.vx = 0;
                this.vy = 0;
                this.updateBoundaries();
            }
        }

        // ============================
        // MAIN APPLICATION
        // ============================
        const physics = new FixedBallPhysics();
        const ball = document.getElementById('ball');
        const shadow = document.querySelector('.ball-shadow');
        const permissionPrompt = document.getElementById('permissionPrompt');
        
        let animationId = null;
        let lastTime = 0;

        // Initialize app
        function init() {
            setupEventListeners();
            
            // Hide permission prompt for non-iOS devices
            if (!(typeof DeviceOrientationEvent !== 'undefined' && 
                  typeof DeviceOrientationEvent.requestPermission === 'function')) {
                physics.startGyroListening();
                permissionPrompt.classList.add('hidden');
                startAnimation();
            }
        }

        // Grant permission button
        document.getElementById('grantPermissionBtn').addEventListener('click', async () => {
            const granted = await physics.requestPermission();
            if (granted) {
                permissionPrompt.classList.add('hidden');
                startAnimation();
            } else {
                alert("Sensor gerak diperlukan untuk pengalaman terbaik. Anda masih bisa menggerakkan bola dengan sentuhan.");
                permissionPrompt.classList.add('hidden');
                startAnimation();
            }
        });

        // Start animation loop
        function startAnimation() {
            function animate(currentTime) {
                const deltaTime = lastTime ? currentTime - lastTime : 16.67;
                lastTime = currentTime;
                
                // Update physics
                const state = physics.update();
                
                // Update ball position
                updateBall(state);
                
                // Update shadow
                updateShadow(state);
                
                // Continue animation
                animationId = requestAnimationFrame(animate);
            }
            
            animationId = requestAnimationFrame(animate);
        }

        function updateBall(state) {
            // Calculate rotation based on movement
            const rotation = state.vx * 1.2;
            
            // Apply transformations - state.x dan state.y sudah top-left position
            ball.style.transform = `
                translate3d(${state.x}px, ${state.y}px, 0)
                rotate(${rotation}deg)
            `;
        }

        function updateShadow(state) {
            const speed = Math.sqrt(state.vx * state.vx + state.vy * state.vy);
            const heightFactor = (state.y - physics.minY) / (physics.maxY - physics.minY);
            
            const shadowSize = 0.7 + (1 - heightFactor) * 0.3;
            const shadowOpacity = 0.3 - heightFactor * 0.1;
            
            shadow.style.width = `${80 * shadowSize}px`;
            shadow.style.height = `${20 * shadowSize}px`;
            shadow.style.opacity = Math.max(0.1, Math.min(0.5, shadowOpacity));
            shadow.style.left = `${state.x + 10}px`;
            shadow.style.top = `${state.y + 70}px`;
        }

        // Event listeners
        function setupEventListeners() {
            // Window resize
            window.addEventListener('resize', () => {
                physics.updateBoundaries();
                physics.clampToBoundaries();
            });

            // Ball touch interaction
            ball.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                physics.startDrag(touch.clientX, touch.clientY);
                
                // Visual feedback
                ball.style.boxShadow = 
                    'inset -4px -4px 12px rgba(0,0,0,0.3), ' +
                    'inset 4px 4px 12px rgba(255,255,255,0.6), ' +
                    '0 20px 40px rgba(0,0,0,0.4)';
            });

            ball.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                physics.updateDrag(touch.clientX, touch.clientY);
            });

            document.addEventListener('touchend', () => {
                physics.endDrag();
                // Reset shadow
                ball.style.boxShadow = 
                    'inset -8px -8px 16px rgba(0,0,0,0.2), ' +
                    'inset 8px 8px 16px rgba(255,255,255,0.6), ' +
                    '0 15px 30px rgba(0,0,0,0.3)';
            });

            // Double tap to push
            let lastTap = 0;
            ball.addEventListener('touchend', (e) => {
                const currentTime = Date.now();
                const tapLength = currentTime - lastTap;
                
                if (tapLength < 300) {
                    // Double tap - push away from tap point
                    const touch = e.changedTouches[0];
                    const dx = physics.x - touch.clientX;
                    const dy = physics.y - touch.clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 0) {
                        const force = 10 / distance;
                        physics.addImpulse(dx * force, dy * force);
                    }
                }
                
                lastTap = currentTime;
            });

            // Tap anywhere to push toward tap point
            document.addEventListener('touchend', (e) => {
                if (e.target === ball) return;
                
                const touch = e.changedTouches[0];
                const dx = touch.clientX - physics.x;
                const dy = touch.clientY - physics.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    const force = 8 / distance;
                    physics.addImpulse(dx * force, dy * force);
                }
            });
        }

        // Start the app
        window.addEventListener('load', init);
    </script>
</body>
</html>
