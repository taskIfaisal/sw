<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magic Card - Natural Physics</title>
    <link rel="apple-touch-icon" href="./icon/card2phone-512x512.png">
    <link rel="apple-touch-startup-image" href="./icon/card2phone-512x512.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Magic Card">
    <link rel="icon" type="image/png" sizes="192x192" href="./icon/card2phone-512x512.png">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        
        #background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            opacity: 0.9;
        }
        
        #card {
            position: absolute;
            width: 180px;
            height: 250px;
            border-radius: 12px;
            background: white;
            box-shadow: 
                0 20px 40px rgba(0,0,0,0.3),
                0 0 0 1px rgba(255,255,255,0.1),
                0 0 30px rgba(255,255,255,0.1);
            z-index: 2;
            transform-origin: center center;
            overflow: hidden;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }

        #card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        #card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(
                135deg,
                rgba(255,255,255,0.3) 0%,
                rgba(255,255,255,0.1) 50%,
                transparent 100%
            );
            border-radius: 12px;
            pointer-events: none;
        }

        .card-shadow {
            position: absolute;
            width: 150px;
            height: 20px;
            background: radial-gradient(ellipse at center, 
                rgba(0,0,0,0.4) 0%,
                rgba(0,0,0,0) 80%);
            border-radius: 50%;
            z-index: 1;
            transition: all 0.2s ease;
        }

        /* Simple touch hint */
        .touch-hint {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255,255,255,0.8);
            font-size: 18px;
            text-align: center;
            z-index: 3;
            animation: fadeOut 3s forwards;
            pointer-events: none;
        }

        @keyframes fadeOut {
            0% { opacity: 1; }
            70% { opacity: 1; }
            100% { opacity: 0; }
        }

        /* Simple settings */
        #settings-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
            font-size: 24px;
            cursor: pointer;
            z-index: 10;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #settings-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.1);
        }

        .settings-panel {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(255,255,255,0.95);
            border-radius: 12px;
            padding: 15px;
            z-index: 10;
            backdrop-filter: blur(20px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            transform: scale(0.9);
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .settings-panel.show {
            transform: scale(1);
            opacity: 1;
            pointer-events: all;
        }

        .settings-panel button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            margin: 5px 0;
            width: 100%;
            font-size: 16px;
        }

        .settings-panel label {
            display: block;
            padding: 10px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 8px;
            margin: 5px 0;
            cursor: pointer;
            text-align: center;
            color: #667eea;
        }

        input[type="file"] {
            display: none;
        }
    </style>
</head>
<body>
    <div id="background"></div>
    <div id="card">
        <img src="https://deckofcardsapi.com/static/img/AS.png" alt="Magic Card">
    </div>
    <div class="card-shadow"></div>
    
    <div class="touch-hint">
        ‚ö° Miringkan HP untuk menggerakkan kartu<br>
        üëÜ Sentuh untuk mendorong
    </div>
    
    <button id="settings-btn">‚öôÔ∏è</button>
    
    <div class="settings-panel">
        <h3 style="margin: 0 0 15px 0; color: #333;">Magic Card</h3>
        <label>
            üìÅ Pilih Kartu
            <input type="file" id="card-upload" accept="image/*">
        </label>
        <label>
            üé® Pilih Background
            <input type="file" id="bg-upload" accept="image/*">
        </label>
        <button id="default-card">üîÑ Kartu Default</button>
        <button id="reset-position">üìç Tengahkan</button>
        <button id="close-settings">‚úï Tutup</button>
    </div>

    <script>
        // ============================
        // SIMPLE PHYSICS ENGINE
        // ============================
        class SimplePhysics {
            constructor() {
                // Position and velocity
                this.x = window.innerWidth / 2 - 90;
                this.y = window.innerHeight / 2 - 125;
                this.vx = 0;
                this.vy = 0;
                
                // Fixed physics properties (simple and natural)
                this.gravity = 0.5;
                this.friction = 0.96;
                this.bounce = 0.7;
                this.responsiveness = 0.8;
                
                // Card size
                this.width = 180;
                this.height = 250;
                
                // Gyro data
                this.beta = 0;
                this.gamma = 0;
                this.gyroAvailable = false;
                
                // Touch
                this.isDragging = false;
                this.lastTouchTime = 0;
                
                // Initialize
                this.updateBoundaries();
                this.initGyro();
            }
            
            updateBoundaries() {
                this.minX = 10;
                this.minY = 10;
                this.maxX = window.innerWidth - this.width - 10;
                this.maxY = window.innerHeight - this.height - 10;
            }
            
            initGyro() {
                if (window.DeviceOrientationEvent) {
                    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                        // iOS 13+ - request permission on first interaction
                        setTimeout(() => {
                            this.requestGyroPermission();
                        }, 1000);
                    } else {
                        this.gyroAvailable = true;
                        window.addEventListener('deviceorientation', (e) => {
                            this.beta = (e.beta || 0) / 90;  // Normalize to -1 to 1
                            this.gamma = (e.gamma || 0) / 45; // Normalize to -1 to 1
                        });
                    }
                }
            }
            
            async requestGyroPermission() {
                try {
                    const permission = await DeviceOrientationEvent.requestPermission();
                    if (permission === 'granted') {
                        this.gyroAvailable = true;
                        window.addEventListener('deviceorientation', (e) => {
                            this.beta = (e.beta || 0) / 90;
                            this.gamma = (e.gamma || 0) / 45;
                        });
                    }
                } catch (e) {
                    console.log('Gyro not available');
                }
            }
            
            update() {
                // Apply gyro movement if available
                if (this.gyroAvailable && !this.isDragging) {
                    this.vx += this.gamma * this.responsiveness * 0.1;
                    this.vy += this.beta * this.responsiveness * 0.1;
                }
                
                // Always apply gravity
                this.vy += this.gravity * 0.05;
                
                // Apply friction
                this.vx *= this.friction;
                this.vy *= this.friction;
                
                // Update position
                this.x += this.vx;
                this.y += this.vy;
                
                // Handle screen boundaries with bounce
                this.handleCollisions();
                
                // Keep within screen
                this.x = Math.max(this.minX, Math.min(this.maxX, this.x));
                this.y = Math.max(this.minY, Math.min(this.maxY, this.y));
                
                // Return position for rendering
                return { x: this.x, y: this.y, vx: this.vx, vy: this.vy };
            }
            
            handleCollisions() {
                // Left wall
                if (this.x < this.minX) {
                    this.x = this.minX;
                    this.vx = Math.abs(this.vx) * this.bounce;
                }
                
                // Right wall
                if (this.x > this.maxX) {
                    this.x = this.maxX;
                    this.vx = -Math.abs(this.vx) * this.bounce;
                }
                
                // Top wall
                if (this.y < this.minY) {
                    this.y = this.minY;
                    this.vy = Math.abs(this.vy) * this.bounce;
                }
                
                // Bottom wall
                if (this.y > this.maxY) {
                    this.y = this.maxY;
                    this.vy = -Math.abs(this.vy) * this.bounce;
                }
            }
            
            startDrag(x, y) {
                this.isDragging = true;
                this.dragOffsetX = x - this.x;
                this.dragOffsetY = y - this.y;
                this.vx = 0;
                this.vy = 0;
            }
            
            updateDrag(x, y) {
                if (!this.isDragging) return;
                
                const newX = x - this.dragOffsetX;
                const newY = y - this.dragOffsetY;
                
                // Calculate velocity based on movement
                this.vx = (newX - this.x) * 0.5;
                this.vy = (newY - this.y) * 0.5;
                
                this.x = newX;
                this.y = newY;
            }
            
            endDrag() {
                if (!this.isDragging) return;
                this.isDragging = false;
                
                // Give it a little extra push when released
                this.vx *= 1.5;
                this.vy *= 1.5;
            }
            
            tap(x, y) {
                // Calculate direction from tap point to card center
                const cardCenterX = this.x + this.width / 2;
                const cardCenterY = this.y + this.height / 2;
                const dx = cardCenterX - x;
                const dy = cardCenterY - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Apply impulse away from tap point
                if (distance > 0) {
                    const force = 3000 / (distance * distance);
                    this.vx += (dx / distance) * force;
                    this.vy += (dy / distance) * force;
                }
            }
            
            reset() {
                this.x = window.innerWidth / 2 - this.width / 2;
                this.y = window.innerHeight / 2 - this.height / 2;
                this.vx = 0;
                this.vy = 0;
            }
        }

        // ============================
        // MAIN APPLICATION
        // ============================
        const physics = new SimplePhysics();
        const card = document.getElementById('card');
        const shadow = document.querySelector('.card-shadow');
        const settingsBtn = document.getElementById('settings-btn');
        const settingsPanel = document.querySelector('.settings-panel');
        const touchHint = document.querySelector('.touch-hint');
        
        let lastFrameTime = 0;
        let isAnimating = true;

        // Initialize
        function init() {
            setupEventListeners();
            startAnimation();
            
            // Auto-hide hint after 5 seconds
            setTimeout(() => {
                touchHint.style.display = 'none';
            }, 5000);
        }

        // Animation loop
        function startAnimation() {
            function animate(timestamp) {
                if (!isAnimating) return;
                
                // Calculate delta time for consistent physics
                const deltaTime = lastFrameTime ? (timestamp - lastFrameTime) / 16.67 : 1;
                lastFrameTime = timestamp;
                
                // Update physics
                const state = physics.update();
                
                // Calculate rotation based on velocity (like a rolling ball)
                const rotation = state.vx * 0.5;
                
                // Calculate shadow properties
                const speed = Math.sqrt(state.vx * state.vx + state.vy * state.vy);
                const shadowSize = 0.8 + speed * 0.01;
                const shadowOpacity = 0.5 - speed * 0.01;
                
                // Apply transformations
                card.style.transform = `
                    translate3d(${state.x}px, ${state.y}px, 0)
                    rotate(${rotation}deg)
                `;
                
                // Update shadow
                shadow.style.width = `${150 * shadowSize}px`;
                shadow.style.opacity = Math.max(0.2, Math.min(0.6, shadowOpacity));
                shadow.style.left = `${state.x + 15}px`;
                shadow.style.top = `${state.y + 230}px`;
                
                // Continue animation
                requestAnimationFrame(animate);
            }
            
            requestAnimationFrame(animate);
        }

        // Event listeners
        function setupEventListeners() {
            // Window resize
            window.addEventListener('resize', () => {
                physics.updateBoundaries();
            });

            // Touch events for card
            card.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                physics.startDrag(touch.clientX, touch.clientY);
            });

            card.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (physics.isDragging) {
                    const touch = e.touches[0];
                    physics.updateDrag(touch.clientX, touch.clientY);
                }
            });

            document.addEventListener('touchend', () => {
                physics.endDrag();
            });

            // Double tap to push card
            let lastTap = 0;
            card.addEventListener('touchend', (e) => {
                if (physics.isDragging) return;
                
                const currentTime = new Date().getTime();
                const tapLength = currentTime - lastTap;
                
                if (tapLength < 300 && tapLength > 0) {
                    // Double tap detected
                    const touch = e.changedTouches[0];
                    physics.tap(touch.clientX, touch.clientY);
                }
                
                lastTap = currentTime;
            });

            // Click/tap anywhere to give a little push
            document.addEventListener('touchend', (e) => {
                if (e.target === card || e.target === settingsBtn) return;
                
                const touch = e.changedTouches[0];
                physics.tap(touch.clientX, touch.clientY);
            });

            // Settings button
            settingsBtn.addEventListener('click', () => {
                settingsPanel.classList.toggle('show');
            });

            // Close settings
            document.getElementById('close-settings').addEventListener('click', () => {
                settingsPanel.classList.remove('show');
            });

            // Reset position
            document.getElementById('reset-position').addEventListener('click', () => {
                physics.reset();
                settingsPanel.classList.remove('show');
            });

            // Card upload
            document.getElementById('card-upload').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        card.querySelector('img').src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
                settingsPanel.classList.remove('show');
            });

            // Background upload
            document.getElementById('bg-upload').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        document.getElementById('background').style.backgroundImage = 
                            `url(${event.target.result})`;
                        document.getElementById('background').style.backgroundSize = 'cover';
                    };
                    reader.readAsDataURL(file);
                }
                settingsPanel.classList.remove('show');
            });

            // Default card
            document.getElementById('default-card').addEventListener('click', () => {
                card.querySelector('img').src = "https://deckofcardsapi.com/static/img/AS.png";
                settingsPanel.classList.remove('show');
            });

            // Close settings when clicking outside
            document.addEventListener('touchstart', (e) => {
                if (!settingsPanel.contains(e.target) && 
                    e.target !== settingsBtn && 
                    settingsPanel.classList.contains('show')) {
                    settingsPanel.classList.remove('show');
                }
            });
        }

        // Shake detection for fun
        let lastShake = 0;
        if (window.DeviceMotionEvent) {
            window.addEventListener('devicemotion', (e) => {
                const currentTime = Date.now();
                if (currentTime - lastShake > 2000) { // Only shake every 2 seconds
                    const acceleration = e.accelerationIncludingGravity;
                    if (acceleration) {
                        const totalAccel = Math.abs(acceleration.x) + Math.abs(acceleration.y) + Math.abs(acceleration.z);
                        if (totalAccel > 40) { // Shake detected
                            lastShake = currentTime;
                            physics.vx += (Math.random() - 0.5) * 15;
                            physics.vy += (Math.random() - 0.5) * 15;
                            
                            // Visual feedback
                            document.body.style.backgroundColor = '#ff6b6b';
                            setTimeout(() => {
                                document.body.style.backgroundColor = '';
                            }, 300);
                        }
                    }
                }
            });
        }

        // Start the app
        window.addEventListener('load', init);
    </script>
</body>
</html>
